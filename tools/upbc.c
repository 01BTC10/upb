/*
 * upb - a minimalist implementation of protocol buffers.
 *
 * Copyright (c) 2009 Google Inc.  See LICENSE for details.
 * Author: Josh Haberman <jhaberman@gmail.com>
 *
 * upbc is the upb compiler, which at the moment simply takes a
 * protocol descriptor and outputs a header file containing the
 * names and types of the fields.
 */

#include <ctype.h>
#include <inttypes.h>
#include <stdarg.h>
#include <stdlib.h>
#include "upb/bytestream.h"
#include "upb/def.h"
#include "upb/msg.h"
#include "upb/pb/glue.h"

/* These are in-place string transformations that do not change the length of
 * the string (and thus never need to re-allocate). */

// Convert to C identifier: foo.bar.Baz -> foo_bar_Baz.
static void to_cident(char *str) {
  for (; *str; ++str) {
    if(*str == '.' || *str == '/') *str = '_';
  }
}

// Convert to C proprocessor identifier: foo.bar.Baz -> FOO_BAR_BAZ.
static void to_preproc(char *str) {
  to_cident(str);
  for (; *str; ++str) *str = toupper(*str);
}

/* The _const.h file defines the constants (enums) defined in the .proto
 * file. */
static void write_const_h(upb_def *defs[], int num_entries, char *outfile_name,
                          FILE *stream) {
  /* Header file prologue. */
  char *include_guard_name = strdup(outfile_name);
  to_preproc(include_guard_name);

  fputs("/* This file was generated by upbc (the upb compiler).  "
        "Do not edit. */\n\n", stream),
  fprintf(stream, "#ifndef %s\n", include_guard_name);
  fprintf(stream, "#define %s\n\n", include_guard_name);
  fputs("#ifdef __cplusplus\n", stream);
  fputs("extern \"C\" {\n", stream);
  fputs("#endif\n\n", stream);

  /* Enums. */
  fprintf(stream, "/* Enums. */\n\n");
  for(int i = 0; i < num_entries; i++) {  /* Foreach enum */
    if(defs[i]->type != UPB_DEF_ENUM) continue;
    upb_enumdef *enumdef = upb_downcast_enumdef(defs[i]);
    char *enum_name = strdup(upb_def_fqname(UPB_UPCAST(enumdef)));
    char *enum_val_prefix = strdup(enum_name);
    to_cident(enum_name);
    to_preproc(enum_val_prefix);

    fprintf(stream, "typedef enum %s {\n", enum_name);
    bool first = true;
    /* Foreach enum value. */
    for (upb_enum_iter iter = upb_enum_begin(enumdef);
         !upb_enum_done(iter);
         iter = upb_enum_next(enumdef, iter)) {
      char *value_name = strdup(upb_enum_iter_name(iter));
      uint32_t value = upb_enum_iter_number(iter);
      to_preproc(value_name);
      /* "  GOOGLE_PROTOBUF_FIELDDESCRIPTORPROTO_TYPE_TYPE_UINT32 = 13," */
      if (!first) fputs(",\n", stream);
      first = false;
      fprintf(stream, "  %s_%s = %" PRIu32, enum_val_prefix, value_name, value);
      free(value_name);
    }
    fprintf(stream, "\n} %s;\n\n", enum_name);
    free(enum_name);
    free(enum_val_prefix);
  }

  /* Constants for field names and numbers. */
  fprintf(stream, "/* Constants for field names and numbers. */\n\n");
  for(int i = 0; i < num_entries; i++) {  /* Foreach enum */
    upb_msgdef *m = upb_dyncast_msgdef(defs[i]);
    if(!m) continue;
    char *msg_name = strdup(upb_def_fqname(UPB_UPCAST(m)));
    char *msg_val_prefix = strdup(msg_name);
    to_preproc(msg_val_prefix);
    upb_msg_iter i;
    for(i = upb_msg_begin(m); !upb_msg_done(i); i = upb_msg_next(m, i)) {
      upb_fielddef *f = upb_msg_iter_field(i);
      char *preproc_field_name = strdup(f->name);
      to_preproc(preproc_field_name);
      fprintf(stream, "#define %s_%s__FIELDNUM %d\n",
              msg_val_prefix, preproc_field_name, upb_fielddef_number(f));
      fprintf(stream, "#define %s_%s__FIELDNAME \"%s\"\n",
              msg_val_prefix, preproc_field_name, f->name);
      fprintf(stream, "#define %s_%s__FIELDTYPE %d\n\n",
              msg_val_prefix, preproc_field_name, f->type);
      free(preproc_field_name);
    }
    free(msg_val_prefix);
    free(msg_name);
  }

  /* Epilogue. */
  fputs("#ifdef __cplusplus\n", stream);
  fputs("}  /* extern \"C\" */\n", stream);
  fputs("#endif\n\n", stream);
  fprintf(stream, "#endif  /* %s */\n", include_guard_name);
  free(include_guard_name);
}

const char usage[] =
  "upbc -- upb compiler.\n"
  "upb v0.1  http://blog.reverberate.org/upb/\n"
  "\n"
  "Usage: upbc [options] descriptor-file\n"
  "\n"
  "  -o OUTFILE-BASE    Write to OUTFILE-BASE.h and OUTFILE-BASE.c instead\n"
  "                     of using the input file as a basename.\n"
;

void usage_err(char *err) {
  fprintf(stderr, "upbc: %s\n\n", err);
  fputs(usage, stderr);
  exit(1);
}

void error(char *err, ...) {
  va_list args;
  va_start(args, err);
  fprintf(stderr, "upbc: ");
  vfprintf(stderr, err, args);
  va_end(args);
  exit(1);
}

int main(int argc, char *argv[]) {
  /* Parse arguments. */
  char *outfile_base = NULL, *input_file = NULL;
  for(int i = 1; i < argc; i++) {
    if(strcmp(argv[i], "-o") == 0) {
      if(++i == argc)
        usage_err("-o must be followed by a FILE-BASE.");
      else if(outfile_base)
        usage_err("-o was specified multiple times.");
      outfile_base = argv[i];
    } else {
      if(input_file)
        usage_err("You can only specify one input file.");
      input_file = argv[i];
    }
  }
  if(!input_file) usage_err("You must specify an input file.");
  if(!outfile_base) outfile_base = input_file;

  // Read and parse input file.
  size_t len;
  char *descriptor = upb_readfile(input_file, &len);
  if(!descriptor)
    error("Couldn't read input file.");

  // TODO: make upb_parsedesc use a separate symtab, so we can use it here when
  // importing descriptor.proto.
  upb_symtab *s = upb_symtab_new();
  upb_status status = UPB_STATUS_INIT;
  upb_read_descriptor(s, descriptor, len, &status);
  if(!upb_ok(&status)) {
    upb_status_print(&status, stderr);
    error("Failed to parse input file descriptor\n");
  }
  upb_status_uninit(&status);

  /* Emit output files. */
  const int maxsize = 256;
  char h_const_filename[maxsize];
  if(snprintf(h_const_filename, maxsize, "%s_const.h", outfile_base) >= maxsize)
    error("File base too long.\n");

  FILE *h_const_file = fopen(h_const_filename, "w");
  if(!h_const_file) error("Failed to open _const.h output file\n");

  int symcount;
  upb_def **defs = upb_symtab_getdefs(s, &symcount, UPB_DEF_ANY);
  write_const_h(defs, symcount, h_const_filename, h_const_file);
  for (int i = 0; i < symcount; i++) upb_def_unref(defs[i]);
  free(defs);
  free(descriptor);
  upb_symtab_unref(s);
  fclose(h_const_file);

  return 0;
}
